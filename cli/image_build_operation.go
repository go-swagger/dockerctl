// Code generated by go-swagger; DO NOT EDIT.

package cli

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"fmt"

	"github.com/go-swagger/dockerctl/client/image"

	"github.com/go-openapi/swag"
	"github.com/spf13/cobra"
)

// makeOperationImageImageBuildCmd returns a cmd to handle operation imageBuild
func makeOperationImageImageBuildCmd() (*cobra.Command, error) {
	cmd := &cobra.Command{
		Use: "ImageBuild",
		Short: `Build an image from a tar archive with a ` + "`" + `Dockerfile` + "`" + ` in it.

The ` + "`" + `Dockerfile` + "`" + ` specifies how the image is built from the tar archive. It is typically in the archive's root, but can be at a different path or have a different name by specifying the ` + "`" + `dockerfile` + "`" + ` parameter. [See the ` + "`" + `Dockerfile` + "`" + ` reference for more information](https://docs.docker.com/engine/reference/builder/).

The Docker daemon performs a preliminary validation of the ` + "`" + `Dockerfile` + "`" + ` before starting the build, and returns an error if the syntax is incorrect. After that, each instruction is run one-by-one until the ID of the new image is output.

The build is canceled if the client drops the connection by quitting or being killed.
`,
		RunE: runOperationImageImageBuild,
	}

	if err := registerOperationImageImageBuildParamFlags(cmd); err != nil {
		return nil, err
	}

	return cmd, nil
}

// runOperationImageImageBuild uses cmd flags to call endpoint api
func runOperationImageImageBuild(cmd *cobra.Command, args []string) error {
	appCli, err := makeClient(cmd, args)
	if err != nil {
		return err
	}
	// retrieve flag values from cmd and fill params
	params := image.NewImageBuildParams()
	if err, _ := retrieveOperationImageImageBuildContentTypeFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildXRegistryConfigFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildBuildargsFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildCachefromFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildCpuperiodFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildCpuquotaFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildCpusetcpusFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildCpusharesFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildDockerfileFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildExtrahostsFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildForcermFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildInputStreamFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildLabelsFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildMemoryFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildMemswapFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildNetworkmodeFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildNocacheFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildOutputsFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildPlatformFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildPullFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildQFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildRemoteFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildRmFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildShmsizeFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildSquashFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildTFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationImageImageBuildTargetFlag(params, "", cmd); err != nil {
		return err
	}
	if dryRun {

		logDebugf("dry-run flag specified. Skip sending request.")
		return nil
	}
	// make request and then print result
	msgStr, err := parseOperationImageImageBuildResult(appCli.Image.ImageBuild(params))
	if err != nil {
		return err
	}
	if !debug {

		fmt.Println(msgStr)
	}
	return nil
}

// registerOperationImageImageBuildParamFlags registers all flags needed to fill params
func registerOperationImageImageBuildParamFlags(cmd *cobra.Command) error {
	if err := registerOperationImageImageBuildContentTypeParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildXRegistryConfigParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildBuildargsParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildCachefromParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildCpuperiodParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildCpuquotaParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildCpusetcpusParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildCpusharesParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildDockerfileParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildExtrahostsParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildForcermParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildInputStreamParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildLabelsParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildMemoryParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildMemswapParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildNetworkmodeParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildNocacheParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildOutputsParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildPlatformParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildPullParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildQParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildRemoteParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildRmParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildShmsizeParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildSquashParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildTParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationImageImageBuildTargetParamFlags("", cmd); err != nil {
		return err
	}
	return nil
}

func registerOperationImageImageBuildContentTypeParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	contentTypeDescription := `Enum: ["application/x-tar"]. `

	var contentTypeFlagName string
	if cmdPrefix == "" {
		contentTypeFlagName = "Content-type"
	} else {
		contentTypeFlagName = fmt.Sprintf("%v.Content-type", cmdPrefix)
	}

	var contentTypeFlagDefault string = "application/x-tar"

	_ = cmd.PersistentFlags().String(contentTypeFlagName, contentTypeFlagDefault, contentTypeDescription)

	if err := cmd.RegisterFlagCompletionFunc(contentTypeFlagName,
		func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
			var res []string
			if err := json.Unmarshal([]byte(`["application/x-tar"]`), &res); err != nil {
				panic(err)
			}
			return res, cobra.ShellCompDirectiveDefault
		}); err != nil {
		return err
	}

	return nil
}
func registerOperationImageImageBuildXRegistryConfigParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	xRegistryConfigDescription := `This is a base64-encoded JSON object with auth configurations for multiple registries that a build may refer to.

The key is a registry URL, and the value is an auth configuration object, [as described in the authentication section](#section/Authentication). For example:

` + "`" + `` + "`" + `` + "`" + `
{
  "docker.example.com": {
    "username": "janedoe",
    "password": "hunter2"
  },
  "https://index.docker.io/v1/": {
    "username": "mobydock",
    "password": "conta1n3rize14"
  }
}
` + "`" + `` + "`" + `` + "`" + `

Only the registry domain name (and port if not the default 443) are required. However, for legacy reasons, the Docker Hub registry must be specified with both a ` + "`" + `https://` + "`" + ` prefix and a ` + "`" + `/v1/` + "`" + ` suffix even though Docker will prefer to use the v2 registry API.
`

	var xRegistryConfigFlagName string
	if cmdPrefix == "" {
		xRegistryConfigFlagName = "X-Registry-Config"
	} else {
		xRegistryConfigFlagName = fmt.Sprintf("%v.X-Registry-Config", cmdPrefix)
	}

	var xRegistryConfigFlagDefault string

	_ = cmd.PersistentFlags().String(xRegistryConfigFlagName, xRegistryConfigFlagDefault, xRegistryConfigDescription)

	return nil
}
func registerOperationImageImageBuildBuildargsParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	buildargsDescription := `JSON map of string pairs for build-time variables. Users pass these values at build-time. Docker uses the buildargs as the environment context for commands run via the ` + "`" + `Dockerfile` + "`" + ` RUN instruction, or for variable expansion in other ` + "`" + `Dockerfile` + "`" + ` instructions. This is not meant for passing secret values.

For example, the build arg ` + "`" + `FOO=bar` + "`" + ` would become ` + "`" + `{"FOO":"bar"}` + "`" + ` in JSON. This would result in the the query parameter ` + "`" + `buildargs={"FOO":"bar"}` + "`" + `. Note that ` + "`" + `{"FOO":"bar"}` + "`" + ` should be URI component encoded.

[Read more about the buildargs instruction.](https://docs.docker.com/engine/reference/builder/#arg)
`

	var buildargsFlagName string
	if cmdPrefix == "" {
		buildargsFlagName = "buildargs"
	} else {
		buildargsFlagName = fmt.Sprintf("%v.buildargs", cmdPrefix)
	}

	var buildargsFlagDefault string

	_ = cmd.PersistentFlags().String(buildargsFlagName, buildargsFlagDefault, buildargsDescription)

	return nil
}
func registerOperationImageImageBuildCachefromParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	cachefromDescription := `JSON array of images used for build cache resolution.`

	var cachefromFlagName string
	if cmdPrefix == "" {
		cachefromFlagName = "cachefrom"
	} else {
		cachefromFlagName = fmt.Sprintf("%v.cachefrom", cmdPrefix)
	}

	var cachefromFlagDefault string

	_ = cmd.PersistentFlags().String(cachefromFlagName, cachefromFlagDefault, cachefromDescription)

	return nil
}
func registerOperationImageImageBuildCpuperiodParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	cpuperiodDescription := `The length of a CPU period in microseconds.`

	var cpuperiodFlagName string
	if cmdPrefix == "" {
		cpuperiodFlagName = "cpuperiod"
	} else {
		cpuperiodFlagName = fmt.Sprintf("%v.cpuperiod", cmdPrefix)
	}

	var cpuperiodFlagDefault int64

	_ = cmd.PersistentFlags().Int64(cpuperiodFlagName, cpuperiodFlagDefault, cpuperiodDescription)

	return nil
}
func registerOperationImageImageBuildCpuquotaParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	cpuquotaDescription := `Microseconds of CPU time that the container can get in a CPU period.`

	var cpuquotaFlagName string
	if cmdPrefix == "" {
		cpuquotaFlagName = "cpuquota"
	} else {
		cpuquotaFlagName = fmt.Sprintf("%v.cpuquota", cmdPrefix)
	}

	var cpuquotaFlagDefault int64

	_ = cmd.PersistentFlags().Int64(cpuquotaFlagName, cpuquotaFlagDefault, cpuquotaDescription)

	return nil
}
func registerOperationImageImageBuildCpusetcpusParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	cpusetcpusDescription := `CPUs in which to allow execution (e.g., ` + "`" + `0-3` + "`" + `, ` + "`" + `0,1` + "`" + `).`

	var cpusetcpusFlagName string
	if cmdPrefix == "" {
		cpusetcpusFlagName = "cpusetcpus"
	} else {
		cpusetcpusFlagName = fmt.Sprintf("%v.cpusetcpus", cmdPrefix)
	}

	var cpusetcpusFlagDefault string

	_ = cmd.PersistentFlags().String(cpusetcpusFlagName, cpusetcpusFlagDefault, cpusetcpusDescription)

	return nil
}
func registerOperationImageImageBuildCpusharesParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	cpusharesDescription := `CPU shares (relative weight).`

	var cpusharesFlagName string
	if cmdPrefix == "" {
		cpusharesFlagName = "cpushares"
	} else {
		cpusharesFlagName = fmt.Sprintf("%v.cpushares", cmdPrefix)
	}

	var cpusharesFlagDefault int64

	_ = cmd.PersistentFlags().Int64(cpusharesFlagName, cpusharesFlagDefault, cpusharesDescription)

	return nil
}
func registerOperationImageImageBuildDockerfileParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	dockerfileDescription := `Path within the build context to the ` + "`" + `Dockerfile` + "`" + `. This is ignored if ` + "`" + `remote` + "`" + ` is specified and points to an external ` + "`" + `Dockerfile` + "`" + `.`

	var dockerfileFlagName string
	if cmdPrefix == "" {
		dockerfileFlagName = "dockerfile"
	} else {
		dockerfileFlagName = fmt.Sprintf("%v.dockerfile", cmdPrefix)
	}

	var dockerfileFlagDefault string = "Dockerfile"

	_ = cmd.PersistentFlags().String(dockerfileFlagName, dockerfileFlagDefault, dockerfileDescription)

	return nil
}
func registerOperationImageImageBuildExtrahostsParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	extrahostsDescription := `Extra hosts to add to /etc/hosts`

	var extrahostsFlagName string
	if cmdPrefix == "" {
		extrahostsFlagName = "extrahosts"
	} else {
		extrahostsFlagName = fmt.Sprintf("%v.extrahosts", cmdPrefix)
	}

	var extrahostsFlagDefault string

	_ = cmd.PersistentFlags().String(extrahostsFlagName, extrahostsFlagDefault, extrahostsDescription)

	return nil
}
func registerOperationImageImageBuildForcermParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	forcermDescription := `Always remove intermediate containers, even upon failure.`

	var forcermFlagName string
	if cmdPrefix == "" {
		forcermFlagName = "forcerm"
	} else {
		forcermFlagName = fmt.Sprintf("%v.forcerm", cmdPrefix)
	}

	var forcermFlagDefault bool

	_ = cmd.PersistentFlags().Bool(forcermFlagName, forcermFlagDefault, forcermDescription)

	return nil
}
func registerOperationImageImageBuildInputStreamParamFlags(cmdPrefix string, cmd *cobra.Command) error {
	// warning: go type io.ReadCloser is not supported by go-swagger cli yet.
	return nil
}
func registerOperationImageImageBuildLabelsParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	labelsDescription := `Arbitrary key/value labels to set on the image, as a JSON map of string pairs.`

	var labelsFlagName string
	if cmdPrefix == "" {
		labelsFlagName = "labels"
	} else {
		labelsFlagName = fmt.Sprintf("%v.labels", cmdPrefix)
	}

	var labelsFlagDefault string

	_ = cmd.PersistentFlags().String(labelsFlagName, labelsFlagDefault, labelsDescription)

	return nil
}
func registerOperationImageImageBuildMemoryParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	memoryDescription := `Set memory limit for build.`

	var memoryFlagName string
	if cmdPrefix == "" {
		memoryFlagName = "memory"
	} else {
		memoryFlagName = fmt.Sprintf("%v.memory", cmdPrefix)
	}

	var memoryFlagDefault int64

	_ = cmd.PersistentFlags().Int64(memoryFlagName, memoryFlagDefault, memoryDescription)

	return nil
}
func registerOperationImageImageBuildMemswapParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	memswapDescription := `Total memory (memory + swap). Set as ` + "`" + `-1` + "`" + ` to disable swap.`

	var memswapFlagName string
	if cmdPrefix == "" {
		memswapFlagName = "memswap"
	} else {
		memswapFlagName = fmt.Sprintf("%v.memswap", cmdPrefix)
	}

	var memswapFlagDefault int64

	_ = cmd.PersistentFlags().Int64(memswapFlagName, memswapFlagDefault, memswapDescription)

	return nil
}
func registerOperationImageImageBuildNetworkmodeParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	networkmodeDescription := `Sets the networking mode for the run commands during build. Supported
standard values are: ` + "`" + `bridge` + "`" + `, ` + "`" + `host` + "`" + `, ` + "`" + `none` + "`" + `, and ` + "`" + `container:<name|id>` + "`" + `.
Any other value is taken as a custom network's name or ID to which this
container should connect to.
`

	var networkmodeFlagName string
	if cmdPrefix == "" {
		networkmodeFlagName = "networkmode"
	} else {
		networkmodeFlagName = fmt.Sprintf("%v.networkmode", cmdPrefix)
	}

	var networkmodeFlagDefault string

	_ = cmd.PersistentFlags().String(networkmodeFlagName, networkmodeFlagDefault, networkmodeDescription)

	return nil
}
func registerOperationImageImageBuildNocacheParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	nocacheDescription := `Do not use the cache when building the image.`

	var nocacheFlagName string
	if cmdPrefix == "" {
		nocacheFlagName = "nocache"
	} else {
		nocacheFlagName = fmt.Sprintf("%v.nocache", cmdPrefix)
	}

	var nocacheFlagDefault bool

	_ = cmd.PersistentFlags().Bool(nocacheFlagName, nocacheFlagDefault, nocacheDescription)

	return nil
}
func registerOperationImageImageBuildOutputsParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	outputsDescription := `BuildKit output configuration`

	var outputsFlagName string
	if cmdPrefix == "" {
		outputsFlagName = "outputs"
	} else {
		outputsFlagName = fmt.Sprintf("%v.outputs", cmdPrefix)
	}

	var outputsFlagDefault string

	_ = cmd.PersistentFlags().String(outputsFlagName, outputsFlagDefault, outputsDescription)

	return nil
}
func registerOperationImageImageBuildPlatformParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	platformDescription := `Platform in the format os[/arch[/variant]]`

	var platformFlagName string
	if cmdPrefix == "" {
		platformFlagName = "platform"
	} else {
		platformFlagName = fmt.Sprintf("%v.platform", cmdPrefix)
	}

	var platformFlagDefault string

	_ = cmd.PersistentFlags().String(platformFlagName, platformFlagDefault, platformDescription)

	return nil
}
func registerOperationImageImageBuildPullParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	pullDescription := `Attempt to pull the image even if an older image exists locally.`

	var pullFlagName string
	if cmdPrefix == "" {
		pullFlagName = "pull"
	} else {
		pullFlagName = fmt.Sprintf("%v.pull", cmdPrefix)
	}

	var pullFlagDefault string

	_ = cmd.PersistentFlags().String(pullFlagName, pullFlagDefault, pullDescription)

	return nil
}
func registerOperationImageImageBuildQParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	qDescription := `Suppress verbose build output.`

	var qFlagName string
	if cmdPrefix == "" {
		qFlagName = "q"
	} else {
		qFlagName = fmt.Sprintf("%v.q", cmdPrefix)
	}

	var qFlagDefault bool

	_ = cmd.PersistentFlags().Bool(qFlagName, qFlagDefault, qDescription)

	return nil
}
func registerOperationImageImageBuildRemoteParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	remoteDescription := `A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the fileâ€™s contents are placed into a file called ` + "`" + `Dockerfile` + "`" + ` and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the ` + "`" + `dockerfile` + "`" + ` parameter is also specified, there must be a file with the corresponding path inside the tarball.`

	var remoteFlagName string
	if cmdPrefix == "" {
		remoteFlagName = "remote"
	} else {
		remoteFlagName = fmt.Sprintf("%v.remote", cmdPrefix)
	}

	var remoteFlagDefault string

	_ = cmd.PersistentFlags().String(remoteFlagName, remoteFlagDefault, remoteDescription)

	return nil
}
func registerOperationImageImageBuildRmParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	rmDescription := `Remove intermediate containers after a successful build.`

	var rmFlagName string
	if cmdPrefix == "" {
		rmFlagName = "rm"
	} else {
		rmFlagName = fmt.Sprintf("%v.rm", cmdPrefix)
	}

	var rmFlagDefault bool = true

	_ = cmd.PersistentFlags().Bool(rmFlagName, rmFlagDefault, rmDescription)

	return nil
}
func registerOperationImageImageBuildShmsizeParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	shmsizeDescription := `Size of ` + "`" + `/dev/shm` + "`" + ` in bytes. The size must be greater than 0. If omitted the system uses 64MB.`

	var shmsizeFlagName string
	if cmdPrefix == "" {
		shmsizeFlagName = "shmsize"
	} else {
		shmsizeFlagName = fmt.Sprintf("%v.shmsize", cmdPrefix)
	}

	var shmsizeFlagDefault int64

	_ = cmd.PersistentFlags().Int64(shmsizeFlagName, shmsizeFlagDefault, shmsizeDescription)

	return nil
}
func registerOperationImageImageBuildSquashParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	squashDescription := `Squash the resulting images layers into a single layer. *(Experimental release only.)*`

	var squashFlagName string
	if cmdPrefix == "" {
		squashFlagName = "squash"
	} else {
		squashFlagName = fmt.Sprintf("%v.squash", cmdPrefix)
	}

	var squashFlagDefault bool

	_ = cmd.PersistentFlags().Bool(squashFlagName, squashFlagDefault, squashDescription)

	return nil
}
func registerOperationImageImageBuildTParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	tDescription := `A name and optional tag to apply to the image in the ` + "`" + `name:tag` + "`" + ` format. If you omit the tag the default ` + "`" + `latest` + "`" + ` value is assumed. You can provide several ` + "`" + `t` + "`" + ` parameters.`

	var tFlagName string
	if cmdPrefix == "" {
		tFlagName = "t"
	} else {
		tFlagName = fmt.Sprintf("%v.t", cmdPrefix)
	}

	var tFlagDefault string

	_ = cmd.PersistentFlags().String(tFlagName, tFlagDefault, tDescription)

	return nil
}
func registerOperationImageImageBuildTargetParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	targetDescription := `Target build stage`

	var targetFlagName string
	if cmdPrefix == "" {
		targetFlagName = "target"
	} else {
		targetFlagName = fmt.Sprintf("%v.target", cmdPrefix)
	}

	var targetFlagDefault string

	_ = cmd.PersistentFlags().String(targetFlagName, targetFlagDefault, targetDescription)

	return nil
}

func retrieveOperationImageImageBuildContentTypeFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("Content-type") {

		var contentTypeFlagName string
		if cmdPrefix == "" {
			contentTypeFlagName = "Content-type"
		} else {
			contentTypeFlagName = fmt.Sprintf("%v.Content-type", cmdPrefix)
		}

		contentTypeFlagValue, err := cmd.Flags().GetString(contentTypeFlagName)
		if err != nil {
			return err, false
		}
		m.ContentType = &contentTypeFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildXRegistryConfigFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("X-Registry-Config") {

		var xRegistryConfigFlagName string
		if cmdPrefix == "" {
			xRegistryConfigFlagName = "X-Registry-Config"
		} else {
			xRegistryConfigFlagName = fmt.Sprintf("%v.X-Registry-Config", cmdPrefix)
		}

		xRegistryConfigFlagValue, err := cmd.Flags().GetString(xRegistryConfigFlagName)
		if err != nil {
			return err, false
		}
		m.XRegistryConfig = &xRegistryConfigFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildBuildargsFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("buildargs") {

		var buildargsFlagName string
		if cmdPrefix == "" {
			buildargsFlagName = "buildargs"
		} else {
			buildargsFlagName = fmt.Sprintf("%v.buildargs", cmdPrefix)
		}

		buildargsFlagValue, err := cmd.Flags().GetString(buildargsFlagName)
		if err != nil {
			return err, false
		}
		m.Buildargs = &buildargsFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildCachefromFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("cachefrom") {

		var cachefromFlagName string
		if cmdPrefix == "" {
			cachefromFlagName = "cachefrom"
		} else {
			cachefromFlagName = fmt.Sprintf("%v.cachefrom", cmdPrefix)
		}

		cachefromFlagValue, err := cmd.Flags().GetString(cachefromFlagName)
		if err != nil {
			return err, false
		}
		m.Cachefrom = &cachefromFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildCpuperiodFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("cpuperiod") {

		var cpuperiodFlagName string
		if cmdPrefix == "" {
			cpuperiodFlagName = "cpuperiod"
		} else {
			cpuperiodFlagName = fmt.Sprintf("%v.cpuperiod", cmdPrefix)
		}

		cpuperiodFlagValue, err := cmd.Flags().GetInt64(cpuperiodFlagName)
		if err != nil {
			return err, false
		}
		m.Cpuperiod = &cpuperiodFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildCpuquotaFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("cpuquota") {

		var cpuquotaFlagName string
		if cmdPrefix == "" {
			cpuquotaFlagName = "cpuquota"
		} else {
			cpuquotaFlagName = fmt.Sprintf("%v.cpuquota", cmdPrefix)
		}

		cpuquotaFlagValue, err := cmd.Flags().GetInt64(cpuquotaFlagName)
		if err != nil {
			return err, false
		}
		m.Cpuquota = &cpuquotaFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildCpusetcpusFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("cpusetcpus") {

		var cpusetcpusFlagName string
		if cmdPrefix == "" {
			cpusetcpusFlagName = "cpusetcpus"
		} else {
			cpusetcpusFlagName = fmt.Sprintf("%v.cpusetcpus", cmdPrefix)
		}

		cpusetcpusFlagValue, err := cmd.Flags().GetString(cpusetcpusFlagName)
		if err != nil {
			return err, false
		}
		m.Cpusetcpus = &cpusetcpusFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildCpusharesFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("cpushares") {

		var cpusharesFlagName string
		if cmdPrefix == "" {
			cpusharesFlagName = "cpushares"
		} else {
			cpusharesFlagName = fmt.Sprintf("%v.cpushares", cmdPrefix)
		}

		cpusharesFlagValue, err := cmd.Flags().GetInt64(cpusharesFlagName)
		if err != nil {
			return err, false
		}
		m.Cpushares = &cpusharesFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildDockerfileFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("dockerfile") {

		var dockerfileFlagName string
		if cmdPrefix == "" {
			dockerfileFlagName = "dockerfile"
		} else {
			dockerfileFlagName = fmt.Sprintf("%v.dockerfile", cmdPrefix)
		}

		dockerfileFlagValue, err := cmd.Flags().GetString(dockerfileFlagName)
		if err != nil {
			return err, false
		}
		m.Dockerfile = &dockerfileFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildExtrahostsFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("extrahosts") {

		var extrahostsFlagName string
		if cmdPrefix == "" {
			extrahostsFlagName = "extrahosts"
		} else {
			extrahostsFlagName = fmt.Sprintf("%v.extrahosts", cmdPrefix)
		}

		extrahostsFlagValue, err := cmd.Flags().GetString(extrahostsFlagName)
		if err != nil {
			return err, false
		}
		m.Extrahosts = &extrahostsFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildForcermFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("forcerm") {

		var forcermFlagName string
		if cmdPrefix == "" {
			forcermFlagName = "forcerm"
		} else {
			forcermFlagName = fmt.Sprintf("%v.forcerm", cmdPrefix)
		}

		forcermFlagValue, err := cmd.Flags().GetBool(forcermFlagName)
		if err != nil {
			return err, false
		}
		m.Forcerm = &forcermFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildInputStreamFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("inputStream") {
		// warning: io.ReadCloser is not supported by go-swagger cli yet
	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildLabelsFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("labels") {

		var labelsFlagName string
		if cmdPrefix == "" {
			labelsFlagName = "labels"
		} else {
			labelsFlagName = fmt.Sprintf("%v.labels", cmdPrefix)
		}

		labelsFlagValue, err := cmd.Flags().GetString(labelsFlagName)
		if err != nil {
			return err, false
		}
		m.Labels = &labelsFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildMemoryFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("memory") {

		var memoryFlagName string
		if cmdPrefix == "" {
			memoryFlagName = "memory"
		} else {
			memoryFlagName = fmt.Sprintf("%v.memory", cmdPrefix)
		}

		memoryFlagValue, err := cmd.Flags().GetInt64(memoryFlagName)
		if err != nil {
			return err, false
		}
		m.Memory = &memoryFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildMemswapFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("memswap") {

		var memswapFlagName string
		if cmdPrefix == "" {
			memswapFlagName = "memswap"
		} else {
			memswapFlagName = fmt.Sprintf("%v.memswap", cmdPrefix)
		}

		memswapFlagValue, err := cmd.Flags().GetInt64(memswapFlagName)
		if err != nil {
			return err, false
		}
		m.Memswap = &memswapFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildNetworkmodeFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("networkmode") {

		var networkmodeFlagName string
		if cmdPrefix == "" {
			networkmodeFlagName = "networkmode"
		} else {
			networkmodeFlagName = fmt.Sprintf("%v.networkmode", cmdPrefix)
		}

		networkmodeFlagValue, err := cmd.Flags().GetString(networkmodeFlagName)
		if err != nil {
			return err, false
		}
		m.Networkmode = &networkmodeFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildNocacheFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("nocache") {

		var nocacheFlagName string
		if cmdPrefix == "" {
			nocacheFlagName = "nocache"
		} else {
			nocacheFlagName = fmt.Sprintf("%v.nocache", cmdPrefix)
		}

		nocacheFlagValue, err := cmd.Flags().GetBool(nocacheFlagName)
		if err != nil {
			return err, false
		}
		m.Nocache = &nocacheFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildOutputsFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("outputs") {

		var outputsFlagName string
		if cmdPrefix == "" {
			outputsFlagName = "outputs"
		} else {
			outputsFlagName = fmt.Sprintf("%v.outputs", cmdPrefix)
		}

		outputsFlagValue, err := cmd.Flags().GetString(outputsFlagName)
		if err != nil {
			return err, false
		}
		m.Outputs = &outputsFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildPlatformFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("platform") {

		var platformFlagName string
		if cmdPrefix == "" {
			platformFlagName = "platform"
		} else {
			platformFlagName = fmt.Sprintf("%v.platform", cmdPrefix)
		}

		platformFlagValue, err := cmd.Flags().GetString(platformFlagName)
		if err != nil {
			return err, false
		}
		m.Platform = &platformFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildPullFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("pull") {

		var pullFlagName string
		if cmdPrefix == "" {
			pullFlagName = "pull"
		} else {
			pullFlagName = fmt.Sprintf("%v.pull", cmdPrefix)
		}

		pullFlagValue, err := cmd.Flags().GetString(pullFlagName)
		if err != nil {
			return err, false
		}
		m.Pull = &pullFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildQFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("q") {

		var qFlagName string
		if cmdPrefix == "" {
			qFlagName = "q"
		} else {
			qFlagName = fmt.Sprintf("%v.q", cmdPrefix)
		}

		qFlagValue, err := cmd.Flags().GetBool(qFlagName)
		if err != nil {
			return err, false
		}
		m.Q = &qFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildRemoteFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("remote") {

		var remoteFlagName string
		if cmdPrefix == "" {
			remoteFlagName = "remote"
		} else {
			remoteFlagName = fmt.Sprintf("%v.remote", cmdPrefix)
		}

		remoteFlagValue, err := cmd.Flags().GetString(remoteFlagName)
		if err != nil {
			return err, false
		}
		m.Remote = &remoteFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildRmFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("rm") {

		var rmFlagName string
		if cmdPrefix == "" {
			rmFlagName = "rm"
		} else {
			rmFlagName = fmt.Sprintf("%v.rm", cmdPrefix)
		}

		rmFlagValue, err := cmd.Flags().GetBool(rmFlagName)
		if err != nil {
			return err, false
		}
		m.Rm = &rmFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildShmsizeFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("shmsize") {

		var shmsizeFlagName string
		if cmdPrefix == "" {
			shmsizeFlagName = "shmsize"
		} else {
			shmsizeFlagName = fmt.Sprintf("%v.shmsize", cmdPrefix)
		}

		shmsizeFlagValue, err := cmd.Flags().GetInt64(shmsizeFlagName)
		if err != nil {
			return err, false
		}
		m.Shmsize = &shmsizeFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildSquashFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("squash") {

		var squashFlagName string
		if cmdPrefix == "" {
			squashFlagName = "squash"
		} else {
			squashFlagName = fmt.Sprintf("%v.squash", cmdPrefix)
		}

		squashFlagValue, err := cmd.Flags().GetBool(squashFlagName)
		if err != nil {
			return err, false
		}
		m.Squash = &squashFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildTFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("t") {

		var tFlagName string
		if cmdPrefix == "" {
			tFlagName = "t"
		} else {
			tFlagName = fmt.Sprintf("%v.t", cmdPrefix)
		}

		tFlagValue, err := cmd.Flags().GetString(tFlagName)
		if err != nil {
			return err, false
		}
		m.T = &tFlagValue

	}
	return nil, retAdded
}
func retrieveOperationImageImageBuildTargetFlag(m *image.ImageBuildParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("target") {

		var targetFlagName string
		if cmdPrefix == "" {
			targetFlagName = "target"
		} else {
			targetFlagName = fmt.Sprintf("%v.target", cmdPrefix)
		}

		targetFlagValue, err := cmd.Flags().GetString(targetFlagName)
		if err != nil {
			return err, false
		}
		m.Target = &targetFlagValue

	}
	return nil, retAdded
}

// parseOperationImageImageBuildResult parses request result and return the string content
func parseOperationImageImageBuildResult(resp0 *image.ImageBuildOK, respErr error) (string, error) {
	if respErr != nil {

		// Non schema case: warning imageBuildOK is not supported

		var iResp1 interface{} = respErr
		resp1, ok := iResp1.(*image.ImageBuildBadRequest)
		if ok {
			if !swag.IsZero(resp1) && !swag.IsZero(resp1.Payload) {
				msgStr, err := json.Marshal(resp1.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		var iResp2 interface{} = respErr
		resp2, ok := iResp2.(*image.ImageBuildInternalServerError)
		if ok {
			if !swag.IsZero(resp2) && !swag.IsZero(resp2.Payload) {
				msgStr, err := json.Marshal(resp2.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		return "", respErr
	}

	// warning: non schema response imageBuildOK is not supported by go-swagger cli yet.

	return "", nil
}
