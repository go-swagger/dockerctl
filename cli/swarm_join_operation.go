// Code generated by go-swagger; DO NOT EDIT.

package cli

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"fmt"

	"github.com/go-swagger/dockerctl/client/swarm"

	"github.com/go-openapi/swag"
	"github.com/spf13/cobra"
)

// makeOperationSwarmSwarmJoinCmd returns a cmd to handle operation swarmJoin
func makeOperationSwarmSwarmJoinCmd() (*cobra.Command, error) {
	cmd := &cobra.Command{
		Use:   "SwarmJoin",
		Short: ``,
		RunE:  runOperationSwarmSwarmJoin,
	}

	if err := registerOperationSwarmSwarmJoinParamFlags(cmd); err != nil {
		return nil, err
	}

	return cmd, nil
}

// runOperationSwarmSwarmJoin uses cmd flags to call endpoint api
func runOperationSwarmSwarmJoin(cmd *cobra.Command, args []string) error {
	appCli, err := makeClient(cmd, args)
	if err != nil {
		return err
	}
	// retrieve flag values from cmd and fill params
	params := swarm.NewSwarmJoinParams()
	if err, _ := retrieveOperationSwarmSwarmJoinBodyFlag(params, "", cmd); err != nil {
		return err
	}
	if dryRun {

		logDebugf("dry-run flag specified. Skip sending request.")
		return nil
	}
	// make request and then print result
	msgStr, err := parseOperationSwarmSwarmJoinResult(appCli.Swarm.SwarmJoin(params))
	if err != nil {
		return err
	}
	if !debug {

		fmt.Println(msgStr)
	}
	return nil
}

// registerOperationSwarmSwarmJoinParamFlags registers all flags needed to fill params
func registerOperationSwarmSwarmJoinParamFlags(cmd *cobra.Command) error {
	if err := registerOperationSwarmSwarmJoinBodyParamFlags("", cmd); err != nil {
		return err
	}
	return nil
}

func registerOperationSwarmSwarmJoinBodyParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	var bodyFlagName string
	if cmdPrefix == "" {
		bodyFlagName = "body"
	} else {
		bodyFlagName = fmt.Sprintf("%v.body", cmdPrefix)
	}

	_ = cmd.PersistentFlags().String(bodyFlagName, "", "Optional json string for [body]. ")

	// add flags for body
	if err := registerModelSwarmJoinBodyFlags(0, "swarmJoinBody", cmd); err != nil {
		return err
	}

	return nil
}

func retrieveOperationSwarmSwarmJoinBodyFlag(m *swarm.SwarmJoinParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("body") {
		// Read body string from cmd and unmarshal
		bodyValueStr, err := cmd.Flags().GetString("body")
		if err != nil {
			return err, false
		}

		bodyValue := swarm.SwarmJoinBody{}
		if err := json.Unmarshal([]byte(bodyValueStr), &bodyValue); err != nil {
			return fmt.Errorf("cannot unmarshal body string in SwarmJoinBody: %v", err), false
		}
		m.Body = bodyValue
	}
	bodyValueModel := m.Body
	if swag.IsZero(bodyValueModel) {
		bodyValueModel = swarm.SwarmJoinBody{}
	}
	err, added := retrieveModelSwarmJoinBodyFlags(0, &bodyValueModel, "swarmJoinBody", cmd)
	if err != nil {
		return err, false
	}
	if added {
		m.Body = bodyValueModel
	}
	if dryRun && debug {

		bodyValueDebugBytes, err := json.Marshal(m.Body)
		if err != nil {
			return err, false
		}
		logDebugf("Body dry-run payload: %v", string(bodyValueDebugBytes))
	}
	retAdded = retAdded || added

	return nil, retAdded
}

// parseOperationSwarmSwarmJoinResult parses request result and return the string content
func parseOperationSwarmSwarmJoinResult(resp0 *swarm.SwarmJoinOK, respErr error) (string, error) {
	if respErr != nil {

		// Non schema case: warning swarmJoinOK is not supported

		var iResp1 interface{} = respErr
		resp1, ok := iResp1.(*swarm.SwarmJoinBadRequest)
		if ok {
			if !swag.IsZero(resp1.Payload) {
				msgStr, err := json.Marshal(resp1.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		var iResp2 interface{} = respErr
		resp2, ok := iResp2.(*swarm.SwarmJoinInternalServerError)
		if ok {
			if !swag.IsZero(resp2.Payload) {
				msgStr, err := json.Marshal(resp2.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		var iResp3 interface{} = respErr
		resp3, ok := iResp3.(*swarm.SwarmJoinServiceUnavailable)
		if ok {
			if !swag.IsZero(resp3.Payload) {
				msgStr, err := json.Marshal(resp3.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		return "", respErr
	}

	// warning: non schema response swarmJoinOK is not supported by go-swagger cli yet.

	return "", nil
}

// register flags to command
func registerModelSwarmJoinBodyFlags(depth int, cmdPrefix string, cmd *cobra.Command) error {

	if err := registerSwarmJoinBodyAdvertiseAddr(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmJoinBodyDataPathAddr(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmJoinBodyJoinToken(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmJoinBodyListenAddr(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmJoinBodyRemoteAddrs(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	return nil
}

func registerSwarmJoinBodyAdvertiseAddr(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	advertiseAddrDescription := `Externally reachable address advertised to other nodes. This can either be an address/port combination in the form ` + "`" + `192.168.1.1:4567` + "`" + `, or an interface followed by a port number, like ` + "`" + `eth0:4567` + "`" + `. If the port number is omitted, the port number from the listen address is used. If ` + "`" + `AdvertiseAddr` + "`" + ` is not specified, it will be automatically detected when possible.`

	var advertiseAddrFlagName string
	if cmdPrefix == "" {
		advertiseAddrFlagName = "AdvertiseAddr"
	} else {
		advertiseAddrFlagName = fmt.Sprintf("%v.AdvertiseAddr", cmdPrefix)
	}

	var advertiseAddrFlagDefault string

	_ = cmd.PersistentFlags().String(advertiseAddrFlagName, advertiseAddrFlagDefault, advertiseAddrDescription)

	return nil
}

func registerSwarmJoinBodyDataPathAddr(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	dataPathAddrDescription := `Address or interface to use for data path traffic (format: ` + "`" + `<ip|interface>` + "`" + `), for example,  ` + "`" + `192.168.1.1` + "`" + `,
or an interface, like ` + "`" + `eth0` + "`" + `. If ` + "`" + `DataPathAddr` + "`" + ` is unspecified, the same address as ` + "`" + `AdvertiseAddr` + "`" + `
is used.

The ` + "`" + `DataPathAddr` + "`" + ` specifies the address that global scope network drivers will publish towards other
nodes in order to reach the containers running on this node. Using this parameter it is possible to
separate the container data traffic from the management traffic of the cluster.
`

	var dataPathAddrFlagName string
	if cmdPrefix == "" {
		dataPathAddrFlagName = "DataPathAddr"
	} else {
		dataPathAddrFlagName = fmt.Sprintf("%v.DataPathAddr", cmdPrefix)
	}

	var dataPathAddrFlagDefault string

	_ = cmd.PersistentFlags().String(dataPathAddrFlagName, dataPathAddrFlagDefault, dataPathAddrDescription)

	return nil
}

func registerSwarmJoinBodyJoinToken(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	joinTokenDescription := `Secret token for joining this swarm.`

	var joinTokenFlagName string
	if cmdPrefix == "" {
		joinTokenFlagName = "JoinToken"
	} else {
		joinTokenFlagName = fmt.Sprintf("%v.JoinToken", cmdPrefix)
	}

	var joinTokenFlagDefault string

	_ = cmd.PersistentFlags().String(joinTokenFlagName, joinTokenFlagDefault, joinTokenDescription)

	return nil
}

func registerSwarmJoinBodyListenAddr(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	listenAddrDescription := `Listen address used for inter-manager communication if the node gets promoted to manager, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP).`

	var listenAddrFlagName string
	if cmdPrefix == "" {
		listenAddrFlagName = "ListenAddr"
	} else {
		listenAddrFlagName = fmt.Sprintf("%v.ListenAddr", cmdPrefix)
	}

	var listenAddrFlagDefault string

	_ = cmd.PersistentFlags().String(listenAddrFlagName, listenAddrFlagDefault, listenAddrDescription)

	return nil
}

func registerSwarmJoinBodyRemoteAddrs(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	// warning: RemoteAddrs []string array type is not supported by go-swagger cli yet

	return nil
}

// retrieve flags from commands, and set value in model. Return true if any flag is passed by user to fill model field.
func retrieveModelSwarmJoinBodyFlags(depth int, m *swarm.SwarmJoinBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false

	err, advertiseAddrAdded := retrieveSwarmJoinBodyAdvertiseAddrFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || advertiseAddrAdded

	err, dataPathAddrAdded := retrieveSwarmJoinBodyDataPathAddrFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || dataPathAddrAdded

	err, joinTokenAdded := retrieveSwarmJoinBodyJoinTokenFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || joinTokenAdded

	err, listenAddrAdded := retrieveSwarmJoinBodyListenAddrFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || listenAddrAdded

	err, remoteAddrsAdded := retrieveSwarmJoinBodyRemoteAddrsFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || remoteAddrsAdded

	return nil, retAdded
}

func retrieveSwarmJoinBodyAdvertiseAddrFlags(depth int, m *swarm.SwarmJoinBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	advertiseAddrFlagName := fmt.Sprintf("%v.AdvertiseAddr", cmdPrefix)
	if cmd.Flags().Changed(advertiseAddrFlagName) {

		var advertiseAddrFlagName string
		if cmdPrefix == "" {
			advertiseAddrFlagName = "AdvertiseAddr"
		} else {
			advertiseAddrFlagName = fmt.Sprintf("%v.AdvertiseAddr", cmdPrefix)
		}

		advertiseAddrFlagValue, err := cmd.Flags().GetString(advertiseAddrFlagName)
		if err != nil {
			return err, false
		}
		m.AdvertiseAddr = advertiseAddrFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmJoinBodyDataPathAddrFlags(depth int, m *swarm.SwarmJoinBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	dataPathAddrFlagName := fmt.Sprintf("%v.DataPathAddr", cmdPrefix)
	if cmd.Flags().Changed(dataPathAddrFlagName) {

		var dataPathAddrFlagName string
		if cmdPrefix == "" {
			dataPathAddrFlagName = "DataPathAddr"
		} else {
			dataPathAddrFlagName = fmt.Sprintf("%v.DataPathAddr", cmdPrefix)
		}

		dataPathAddrFlagValue, err := cmd.Flags().GetString(dataPathAddrFlagName)
		if err != nil {
			return err, false
		}
		m.DataPathAddr = dataPathAddrFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmJoinBodyJoinTokenFlags(depth int, m *swarm.SwarmJoinBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	joinTokenFlagName := fmt.Sprintf("%v.JoinToken", cmdPrefix)
	if cmd.Flags().Changed(joinTokenFlagName) {

		var joinTokenFlagName string
		if cmdPrefix == "" {
			joinTokenFlagName = "JoinToken"
		} else {
			joinTokenFlagName = fmt.Sprintf("%v.JoinToken", cmdPrefix)
		}

		joinTokenFlagValue, err := cmd.Flags().GetString(joinTokenFlagName)
		if err != nil {
			return err, false
		}
		m.JoinToken = joinTokenFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmJoinBodyListenAddrFlags(depth int, m *swarm.SwarmJoinBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	listenAddrFlagName := fmt.Sprintf("%v.ListenAddr", cmdPrefix)
	if cmd.Flags().Changed(listenAddrFlagName) {

		var listenAddrFlagName string
		if cmdPrefix == "" {
			listenAddrFlagName = "ListenAddr"
		} else {
			listenAddrFlagName = fmt.Sprintf("%v.ListenAddr", cmdPrefix)
		}

		listenAddrFlagValue, err := cmd.Flags().GetString(listenAddrFlagName)
		if err != nil {
			return err, false
		}
		m.ListenAddr = listenAddrFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmJoinBodyRemoteAddrsFlags(depth int, m *swarm.SwarmJoinBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	remoteAddrsFlagName := fmt.Sprintf("%v.RemoteAddrs", cmdPrefix)
	if cmd.Flags().Changed(remoteAddrsFlagName) {
		// warning: RemoteAddrs array type []string is not supported by go-swagger cli yet
	}

	return nil, retAdded
}
