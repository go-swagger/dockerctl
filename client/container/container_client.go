// Code generated by go-swagger; DO NOT EDIT.

package container

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new container API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for container API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	ContainerArchive(params *ContainerArchiveParams, opts ...ClientOption) (*ContainerArchiveOK, error)

	ContainerArchiveInfo(params *ContainerArchiveInfoParams, opts ...ClientOption) (*ContainerArchiveInfoOK, error)

	ContainerAttach(params *ContainerAttachParams, opts ...ClientOption) (*ContainerAttachOK, error)

	ContainerAttachWebsocket(params *ContainerAttachWebsocketParams, opts ...ClientOption) (*ContainerAttachWebsocketOK, error)

	ContainerChanges(params *ContainerChangesParams, opts ...ClientOption) (*ContainerChangesOK, error)

	ContainerCreate(params *ContainerCreateParams, opts ...ClientOption) (*ContainerCreateCreated, error)

	ContainerDelete(params *ContainerDeleteParams, opts ...ClientOption) (*ContainerDeleteNoContent, error)

	ContainerExport(params *ContainerExportParams, opts ...ClientOption) (*ContainerExportOK, error)

	ContainerInspect(params *ContainerInspectParams, opts ...ClientOption) (*ContainerInspectOK, error)

	ContainerKill(params *ContainerKillParams, opts ...ClientOption) (*ContainerKillNoContent, error)

	ContainerList(params *ContainerListParams, opts ...ClientOption) (*ContainerListOK, error)

	ContainerLogs(params *ContainerLogsParams, writer io.Writer, opts ...ClientOption) (*ContainerLogsOK, error)

	ContainerPause(params *ContainerPauseParams, opts ...ClientOption) (*ContainerPauseNoContent, error)

	ContainerPrune(params *ContainerPruneParams, opts ...ClientOption) (*ContainerPruneOK, error)

	ContainerRename(params *ContainerRenameParams, opts ...ClientOption) (*ContainerRenameNoContent, error)

	ContainerResize(params *ContainerResizeParams, opts ...ClientOption) (*ContainerResizeOK, error)

	ContainerRestart(params *ContainerRestartParams, opts ...ClientOption) (*ContainerRestartNoContent, error)

	ContainerStart(params *ContainerStartParams, opts ...ClientOption) (*ContainerStartNoContent, error)

	ContainerStats(params *ContainerStatsParams, opts ...ClientOption) (*ContainerStatsOK, error)

	ContainerStop(params *ContainerStopParams, opts ...ClientOption) (*ContainerStopNoContent, error)

	ContainerTop(params *ContainerTopParams, opts ...ClientOption) (*ContainerTopOK, error)

	ContainerUnpause(params *ContainerUnpauseParams, opts ...ClientOption) (*ContainerUnpauseNoContent, error)

	ContainerUpdate(params *ContainerUpdateParams, opts ...ClientOption) (*ContainerUpdateOK, error)

	ContainerWait(params *ContainerWaitParams, opts ...ClientOption) (*ContainerWaitOK, error)

	PutContainerArchive(params *PutContainerArchiveParams, opts ...ClientOption) (*PutContainerArchiveOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  ContainerArchive gets an archive of a filesystem resource in a container

  Get a tar archive of a resource in the filesystem of container id.
*/
func (a *Client) ContainerArchive(params *ContainerArchiveParams, opts ...ClientOption) (*ContainerArchiveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerArchiveParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerArchive",
		Method:             "GET",
		PathPattern:        "/containers/{id}/archive",
		ProducesMediaTypes: []string{"application/x-tar"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerArchiveReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerArchiveOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerArchive: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerArchiveInfo gets information about files in a container

  A response header `X-Docker-Container-Path-Stat` is return containing a base64 - encoded JSON object with some filesystem header information about the path.
*/
func (a *Client) ContainerArchiveInfo(params *ContainerArchiveInfoParams, opts ...ClientOption) (*ContainerArchiveInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerArchiveInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerArchiveInfo",
		Method:             "HEAD",
		PathPattern:        "/containers/{id}/archive",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerArchiveInfoReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerArchiveInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerArchiveInfo: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerAttach attaches to a container

  Attach to a container to read its output or send it input. You can attach to the same container multiple times and you can reattach to containers that have been detached.

Either the `stream` or `logs` parameter must be `true` for this endpoint to do anything.

See [the documentation for the `docker attach` command](https://docs.docker.com/engine/reference/commandline/attach/) for more details.

### Hijacking

This endpoint hijacks the HTTP connection to transport `stdin`, `stdout`, and `stderr` on the same socket.

This is the response from the daemon for an attach request:

```
HTTP/1.1 200 OK
Content-Type: application/vnd.docker.raw-stream

[STREAM]
```

After the headers and two new lines, the TCP connection can now be used for raw, bidirectional communication between the client and server.

To hint potential proxies about connection hijacking, the Docker client can also optionally send connection upgrade headers.

For example, the client sends this request to upgrade the connection:

```
POST /containers/16253994b7c4/attach?stream=1&stdout=1 HTTP/1.1
Upgrade: tcp
Connection: Upgrade
```

The Docker daemon will respond with a `101 UPGRADED` response, and will similarly follow with the raw stream:

```
HTTP/1.1 101 UPGRADED
Content-Type: application/vnd.docker.raw-stream
Connection: Upgrade
Upgrade: tcp

[STREAM]
```

### Stream format

When the TTY setting is disabled in [`POST /containers/create`](#operation/ContainerCreate), the stream over the hijacked connected is multiplexed to separate out `stdout` and `stderr`. The stream consists of a series of frames, each containing a header and a payload.

The header contains the information which the stream writes (`stdout` or `stderr`). It also contains the size of the associated frame encoded in the last four bytes (`uint32`).

It is encoded on the first eight bytes like this:

```go
header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4}
```

`STREAM_TYPE` can be:

- 0: `stdin` (is written on `stdout`)
- 1: `stdout`
- 2: `stderr`

`SIZE1, SIZE2, SIZE3, SIZE4` are the four bytes of the `uint32` size encoded as big endian.

Following the header is the payload, which is the specified number of bytes of `STREAM_TYPE`.

The simplest way to implement this protocol is the following:

1. Read 8 bytes.
2. Choose `stdout` or `stderr` depending on the first byte.
3. Extract the frame size from the last four bytes.
4. Read the extracted size and output it on the correct output.
5. Goto 1.

### Stream format when using a TTY

When the TTY setting is enabled in [`POST /containers/create`](#operation/ContainerCreate), the stream is not multiplexed. The data exchanged over the hijacked connection is simply the raw data from the process PTY and client's `stdin`.

*/
func (a *Client) ContainerAttach(params *ContainerAttachParams, opts ...ClientOption) (*ContainerAttachOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerAttachParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerAttach",
		Method:             "POST",
		PathPattern:        "/containers/{id}/attach",
		ProducesMediaTypes: []string{"application/vnd.docker.raw-stream"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerAttachReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerAttachOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerAttach: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerAttachWebsocket attaches to a container via a websocket
*/
func (a *Client) ContainerAttachWebsocket(params *ContainerAttachWebsocketParams, opts ...ClientOption) (*ContainerAttachWebsocketOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerAttachWebsocketParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerAttachWebsocket",
		Method:             "GET",
		PathPattern:        "/containers/{id}/attach/ws",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerAttachWebsocketReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerAttachWebsocketOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerAttachWebsocket: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerChanges gets changes on a container s filesystem

  Returns which files in a container's filesystem have been added, deleted,
or modified. The `Kind` of modification can be one of:

- `0`: Modified
- `1`: Added
- `2`: Deleted

*/
func (a *Client) ContainerChanges(params *ContainerChangesParams, opts ...ClientOption) (*ContainerChangesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerChangesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerChanges",
		Method:             "GET",
		PathPattern:        "/containers/{id}/changes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerChangesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerChangesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerChanges: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerCreate creates a container
*/
func (a *Client) ContainerCreate(params *ContainerCreateParams, opts ...ClientOption) (*ContainerCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerCreate",
		Method:             "POST",
		PathPattern:        "/containers/create",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/octet-stream"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerCreateReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerCreate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerDelete removes a container
*/
func (a *Client) ContainerDelete(params *ContainerDeleteParams, opts ...ClientOption) (*ContainerDeleteNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerDelete",
		Method:             "DELETE",
		PathPattern:        "/containers/{id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerDeleteReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerDeleteNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerDelete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerExport exports a container

  Export the contents of a container as a tarball.
*/
func (a *Client) ContainerExport(params *ContainerExportParams, opts ...ClientOption) (*ContainerExportOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerExportParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerExport",
		Method:             "GET",
		PathPattern:        "/containers/{id}/export",
		ProducesMediaTypes: []string{"application/octet-stream"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerExportReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerExportOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerExport: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerInspect inspects a container

  Return low-level information about a container.
*/
func (a *Client) ContainerInspect(params *ContainerInspectParams, opts ...ClientOption) (*ContainerInspectOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerInspectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerInspect",
		Method:             "GET",
		PathPattern:        "/containers/{id}/json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerInspectReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerInspectOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerInspect: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerKill kills a container

  Send a POSIX signal to a container, defaulting to killing to the container.
*/
func (a *Client) ContainerKill(params *ContainerKillParams, opts ...ClientOption) (*ContainerKillNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerKillParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerKill",
		Method:             "POST",
		PathPattern:        "/containers/{id}/kill",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerKillReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerKillNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerKill: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerList lists containers

  Returns a list of containers. For details on the format, see [the inspect endpoint](#operation/ContainerInspect).

Note that it uses a different, smaller representation of a container than inspecting a single container. For example,
the list of linked containers is not propagated .

*/
func (a *Client) ContainerList(params *ContainerListParams, opts ...ClientOption) (*ContainerListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerList",
		Method:             "GET",
		PathPattern:        "/containers/json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerListReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerList: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerLogs gets container logs

  Get `stdout` and `stderr` logs from a container.

Note: This endpoint works only for containers with the `json-file` or `journald` logging driver.

*/
func (a *Client) ContainerLogs(params *ContainerLogsParams, writer io.Writer, opts ...ClientOption) (*ContainerLogsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerLogsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerLogs",
		Method:             "GET",
		PathPattern:        "/containers/{id}/logs",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerLogsReader{formats: a.formats, writer: writer},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerLogsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerLogs: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerPause pauses a container

  Use the freezer cgroup to suspend all processes in a container.

Traditionally, when suspending a process the `SIGSTOP` signal is used, which is observable by the process being suspended. With the freezer cgroup the process is unaware, and unable to capture, that it is being suspended, and subsequently resumed.

*/
func (a *Client) ContainerPause(params *ContainerPauseParams, opts ...ClientOption) (*ContainerPauseNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerPauseParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerPause",
		Method:             "POST",
		PathPattern:        "/containers/{id}/pause",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerPauseReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerPauseNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerPause: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerPrune deletes stopped containers
*/
func (a *Client) ContainerPrune(params *ContainerPruneParams, opts ...ClientOption) (*ContainerPruneOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerPruneParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerPrune",
		Method:             "POST",
		PathPattern:        "/containers/prune",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerPruneReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerPruneOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerPrune: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerRename renames a container
*/
func (a *Client) ContainerRename(params *ContainerRenameParams, opts ...ClientOption) (*ContainerRenameNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerRenameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerRename",
		Method:             "POST",
		PathPattern:        "/containers/{id}/rename",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerRenameReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerRenameNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerRename: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerResize resizes a container t t y

  Resize the TTY for a container.
*/
func (a *Client) ContainerResize(params *ContainerResizeParams, opts ...ClientOption) (*ContainerResizeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerResizeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerResize",
		Method:             "POST",
		PathPattern:        "/containers/{id}/resize",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/octet-stream"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerResizeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerResizeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerResize: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerRestart restarts a container
*/
func (a *Client) ContainerRestart(params *ContainerRestartParams, opts ...ClientOption) (*ContainerRestartNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerRestartParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerRestart",
		Method:             "POST",
		PathPattern:        "/containers/{id}/restart",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerRestartReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerRestartNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerRestart: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerStart starts a container
*/
func (a *Client) ContainerStart(params *ContainerStartParams, opts ...ClientOption) (*ContainerStartNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerStartParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerStart",
		Method:             "POST",
		PathPattern:        "/containers/{id}/start",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerStartReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerStartNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerStart: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerStats gets container stats based on resource usage

  This endpoint returns a live stream of a containerâ€™s resource usage
statistics.

The `precpu_stats` is the CPU statistic of the *previous* read, and is
used to calculate the CPU usage percentage. It is not an exact copy
of the `cpu_stats` field.

If either `precpu_stats.online_cpus` or `cpu_stats.online_cpus` is
nil then for compatibility with older daemons the length of the
corresponding `cpu_usage.percpu_usage` array should be used.

*/
func (a *Client) ContainerStats(params *ContainerStatsParams, opts ...ClientOption) (*ContainerStatsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerStatsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerStats",
		Method:             "GET",
		PathPattern:        "/containers/{id}/stats",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerStatsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerStatsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerStats: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerStop stops a container
*/
func (a *Client) ContainerStop(params *ContainerStopParams, opts ...ClientOption) (*ContainerStopNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerStopParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerStop",
		Method:             "POST",
		PathPattern:        "/containers/{id}/stop",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerStopReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerStopNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerStop: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerTop lists processes running inside a container

  On Unix systems, this is done by running the `ps` command. This endpoint is not supported on Windows.
*/
func (a *Client) ContainerTop(params *ContainerTopParams, opts ...ClientOption) (*ContainerTopOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerTopParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerTop",
		Method:             "GET",
		PathPattern:        "/containers/{id}/top",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerTopReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerTopOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerTop: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerUnpause unpauses a container

  Resume a container which has been paused.
*/
func (a *Client) ContainerUnpause(params *ContainerUnpauseParams, opts ...ClientOption) (*ContainerUnpauseNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerUnpauseParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerUnpause",
		Method:             "POST",
		PathPattern:        "/containers/{id}/unpause",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerUnpauseReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerUnpauseNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerUnpause: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerUpdate updates a container

  Change various configuration options of a container without having to recreate it.
*/
func (a *Client) ContainerUpdate(params *ContainerUpdateParams, opts ...ClientOption) (*ContainerUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerUpdate",
		Method:             "POST",
		PathPattern:        "/containers/{id}/update",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerUpdateReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerUpdateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerUpdate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ContainerWait waits for a container

  Block until a container stops, then returns the exit code.
*/
func (a *Client) ContainerWait(params *ContainerWaitParams, opts ...ClientOption) (*ContainerWaitOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerWaitParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ContainerWait",
		Method:             "POST",
		PathPattern:        "/containers/{id}/wait",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ContainerWaitReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ContainerWaitOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ContainerWait: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PutContainerArchive extracts an archive of files or folders to a directory in a container

  Upload a tar archive to be extracted to a path in the filesystem of container id.
*/
func (a *Client) PutContainerArchive(params *PutContainerArchiveParams, opts ...ClientOption) (*PutContainerArchiveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutContainerArchiveParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PutContainerArchive",
		Method:             "PUT",
		PathPattern:        "/containers/{id}/archive",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/octet-stream", "application/x-tar"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutContainerArchiveReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutContainerArchiveOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for PutContainerArchive: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
