// Code generated by go-swagger; DO NOT EDIT.

package image

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new image API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for image API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	BuildPrune(params *BuildPruneParams, opts ...ClientOption) (*BuildPruneOK, error)

	ImageBuild(params *ImageBuildParams, opts ...ClientOption) (*ImageBuildOK, error)

	ImageCommit(params *ImageCommitParams, opts ...ClientOption) (*ImageCommitCreated, error)

	ImageCreate(params *ImageCreateParams, opts ...ClientOption) (*ImageCreateOK, error)

	ImageDelete(params *ImageDeleteParams, opts ...ClientOption) (*ImageDeleteOK, error)

	ImageGet(params *ImageGetParams, writer io.Writer, opts ...ClientOption) (*ImageGetOK, error)

	ImageGetAll(params *ImageGetAllParams, writer io.Writer, opts ...ClientOption) (*ImageGetAllOK, error)

	ImageHistory(params *ImageHistoryParams, opts ...ClientOption) (*ImageHistoryOK, error)

	ImageInspect(params *ImageInspectParams, opts ...ClientOption) (*ImageInspectOK, error)

	ImageList(params *ImageListParams, opts ...ClientOption) (*ImageListOK, error)

	ImageLoad(params *ImageLoadParams, opts ...ClientOption) (*ImageLoadOK, error)

	ImagePrune(params *ImagePruneParams, opts ...ClientOption) (*ImagePruneOK, error)

	ImagePush(params *ImagePushParams, opts ...ClientOption) (*ImagePushOK, error)

	ImageSearch(params *ImageSearchParams, opts ...ClientOption) (*ImageSearchOK, error)

	ImageTag(params *ImageTagParams, opts ...ClientOption) (*ImageTagCreated, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  BuildPrune deletes builder cache
*/
func (a *Client) BuildPrune(params *BuildPruneParams, opts ...ClientOption) (*BuildPruneOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBuildPruneParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "BuildPrune",
		Method:             "POST",
		PathPattern:        "/build/prune",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &BuildPruneReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BuildPruneOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for BuildPrune: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImageBuild builds an image

  Build an image from a tar archive with a `Dockerfile` in it.

The `Dockerfile` specifies how the image is built from the tar archive. It is typically in the archive's root, but can be at a different path or have a different name by specifying the `dockerfile` parameter. [See the `Dockerfile` reference for more information](https://docs.docker.com/engine/reference/builder/).

The Docker daemon performs a preliminary validation of the `Dockerfile` before starting the build, and returns an error if the syntax is incorrect. After that, each instruction is run one-by-one until the ID of the new image is output.

The build is canceled if the client drops the connection by quitting or being killed.

*/
func (a *Client) ImageBuild(params *ImageBuildParams, opts ...ClientOption) (*ImageBuildOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageBuildParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImageBuild",
		Method:             "POST",
		PathPattern:        "/build",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/octet-stream"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageBuildReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImageBuildOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ImageBuild: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImageCommit creates a new image from a container
*/
func (a *Client) ImageCommit(params *ImageCommitParams, opts ...ClientOption) (*ImageCommitCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageCommitParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImageCommit",
		Method:             "POST",
		PathPattern:        "/commit",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageCommitReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImageCommitCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ImageCommit: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImageCreate creates an image

  Create an image by either pulling it from a registry or importing it.
*/
func (a *Client) ImageCreate(params *ImageCreateParams, opts ...ClientOption) (*ImageCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImageCreate",
		Method:             "POST",
		PathPattern:        "/images/create",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/octet-stream", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageCreateReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImageCreateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ImageCreate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImageDelete removes an image

  Remove an image, along with any untagged parent images that were
referenced by that image.

Images can't be removed if they have descendant images, are being
used by a running container or are being used by a build.

*/
func (a *Client) ImageDelete(params *ImageDeleteParams, opts ...ClientOption) (*ImageDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImageDelete",
		Method:             "DELETE",
		PathPattern:        "/images/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageDeleteReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImageDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ImageDelete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImageGet exports an image

  Get a tarball containing all images and metadata for a repository.

If `name` is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned. If `name` is an image ID, similarly only that image (and its parents) are returned, but with the exclusion of the `repositories` file in the tarball, as there were no image names referenced.

### Image tarball format

An image tarball contains one directory per image layer (named using its long ID), each containing these files:

- `VERSION`: currently `1.0` - the file format version
- `json`: detailed layer information, similar to `docker inspect layer_id`
- `layer.tar`: A tarfile containing the filesystem changes in this layer

The `layer.tar` file contains `aufs` style `.wh..wh.aufs` files and directories for storing attribute changes and deletions.

If the tarball defines a repository, the tarball should also include a `repositories` file at the root that contains a list of repository and tag names mapped to layer IDs.

```json
{
  "hello-world": {
    "latest": "565a9d68a73f6706862bfe8409a7f659776d4d60a8d096eb4a3cbce6999cc2a1"
  }
}
```

*/
func (a *Client) ImageGet(params *ImageGetParams, writer io.Writer, opts ...ClientOption) (*ImageGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImageGet",
		Method:             "GET",
		PathPattern:        "/images/{name}/get",
		ProducesMediaTypes: []string{"application/x-tar"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageGetReader{formats: a.formats, writer: writer},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImageGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ImageGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImageGetAll exports several images

  Get a tarball containing all images and metadata for several image repositories.

For each value of the `names` parameter: if it is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned; if it is an image ID, similarly only that image (and its parents) are returned and there would be no names referenced in the 'repositories' file for this image ID.

For details on the format, see [the export image endpoint](#operation/ImageGet).

*/
func (a *Client) ImageGetAll(params *ImageGetAllParams, writer io.Writer, opts ...ClientOption) (*ImageGetAllOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageGetAllParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImageGetAll",
		Method:             "GET",
		PathPattern:        "/images/get",
		ProducesMediaTypes: []string{"application/x-tar"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageGetAllReader{formats: a.formats, writer: writer},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImageGetAllOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ImageGetAll: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImageHistory gets the history of an image

  Return parent layers of an image.
*/
func (a *Client) ImageHistory(params *ImageHistoryParams, opts ...ClientOption) (*ImageHistoryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageHistoryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImageHistory",
		Method:             "GET",
		PathPattern:        "/images/{name}/history",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageHistoryReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImageHistoryOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ImageHistory: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImageInspect inspects an image

  Return low-level information about an image.
*/
func (a *Client) ImageInspect(params *ImageInspectParams, opts ...ClientOption) (*ImageInspectOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageInspectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImageInspect",
		Method:             "GET",
		PathPattern:        "/images/{name}/json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageInspectReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImageInspectOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ImageInspect: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImageList lists images

  Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
*/
func (a *Client) ImageList(params *ImageListParams, opts ...ClientOption) (*ImageListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImageList",
		Method:             "GET",
		PathPattern:        "/images/json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageListReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImageListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ImageList: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImageLoad imports images

  Load a set of images and tags into a repository.

For details on the format, see [the export image endpoint](#operation/ImageGet).

*/
func (a *Client) ImageLoad(params *ImageLoadParams, opts ...ClientOption) (*ImageLoadOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageLoadParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImageLoad",
		Method:             "POST",
		PathPattern:        "/images/load",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/x-tar"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageLoadReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImageLoadOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ImageLoad: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImagePrune deletes unused images
*/
func (a *Client) ImagePrune(params *ImagePruneParams, opts ...ClientOption) (*ImagePruneOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImagePruneParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImagePrune",
		Method:             "POST",
		PathPattern:        "/images/prune",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImagePruneReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImagePruneOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ImagePrune: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImagePush pushes an image

  Push an image to a registry.

If you wish to push an image on to a private registry, that image must already have a tag which references the registry. For example, `registry.example.com/myimage:latest`.

The push is cancelled if the HTTP connection is closed.

*/
func (a *Client) ImagePush(params *ImagePushParams, opts ...ClientOption) (*ImagePushOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImagePushParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImagePush",
		Method:             "POST",
		PathPattern:        "/images/{name}/push",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/octet-stream"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImagePushReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImagePushOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ImagePush: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImageSearch searches images

  Search for an image on Docker Hub.
*/
func (a *Client) ImageSearch(params *ImageSearchParams, opts ...ClientOption) (*ImageSearchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageSearchParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImageSearch",
		Method:             "GET",
		PathPattern:        "/images/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageSearchReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImageSearchOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ImageSearch: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ImageTag tags an image

  Tag an image so that it becomes part of a repository.
*/
func (a *Client) ImageTag(params *ImageTagParams, opts ...ClientOption) (*ImageTagCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImageTagParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImageTag",
		Method:             "POST",
		PathPattern:        "/images/{name}/tag",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImageTagReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImageTagCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ImageTag: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
