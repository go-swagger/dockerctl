// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SwarmSpec User modifiable swarm configuration.
//
// swagger:model SwarmSpec
type SwarmSpec struct {

	// c a config
	CAConfig *SwarmSpecCAConfig `json:"CAConfig,omitempty"`

	// dispatcher
	Dispatcher *SwarmSpecDispatcher `json:"Dispatcher,omitempty"`

	// encryption config
	EncryptionConfig *SwarmSpecEncryptionConfig `json:"EncryptionConfig,omitempty"`

	// User-defined key/value metadata.
	// Example: {"com.example.corp.department":"engineering","com.example.corp.type":"production"}
	Labels map[string]string `json:"Labels,omitempty"`

	// Name of the swarm.
	// Example: default
	Name string `json:"Name,omitempty"`

	// orchestration
	Orchestration *SwarmSpecOrchestration `json:"Orchestration,omitempty"`

	// raft
	Raft *SwarmSpecRaft `json:"Raft,omitempty"`

	// task defaults
	TaskDefaults *SwarmSpecTaskDefaults `json:"TaskDefaults,omitempty"`
}

// Validate validates this swarm spec
func (m *SwarmSpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCAConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDispatcher(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEncryptionConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrchestration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRaft(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaskDefaults(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SwarmSpec) validateCAConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.CAConfig) { // not required
		return nil
	}

	if m.CAConfig != nil {
		if err := m.CAConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("CAConfig")
			}
			return err
		}
	}

	return nil
}

func (m *SwarmSpec) validateDispatcher(formats strfmt.Registry) error {
	if swag.IsZero(m.Dispatcher) { // not required
		return nil
	}

	if m.Dispatcher != nil {
		if err := m.Dispatcher.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Dispatcher")
			}
			return err
		}
	}

	return nil
}

func (m *SwarmSpec) validateEncryptionConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.EncryptionConfig) { // not required
		return nil
	}

	if m.EncryptionConfig != nil {
		if err := m.EncryptionConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("EncryptionConfig")
			}
			return err
		}
	}

	return nil
}

func (m *SwarmSpec) validateOrchestration(formats strfmt.Registry) error {
	if swag.IsZero(m.Orchestration) { // not required
		return nil
	}

	if m.Orchestration != nil {
		if err := m.Orchestration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Orchestration")
			}
			return err
		}
	}

	return nil
}

func (m *SwarmSpec) validateRaft(formats strfmt.Registry) error {
	if swag.IsZero(m.Raft) { // not required
		return nil
	}

	if m.Raft != nil {
		if err := m.Raft.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Raft")
			}
			return err
		}
	}

	return nil
}

func (m *SwarmSpec) validateTaskDefaults(formats strfmt.Registry) error {
	if swag.IsZero(m.TaskDefaults) { // not required
		return nil
	}

	if m.TaskDefaults != nil {
		if err := m.TaskDefaults.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("TaskDefaults")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this swarm spec based on the context it is used
func (m *SwarmSpec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCAConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDispatcher(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEncryptionConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrchestration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRaft(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaskDefaults(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SwarmSpec) contextValidateCAConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.CAConfig != nil {
		if err := m.CAConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("CAConfig")
			}
			return err
		}
	}

	return nil
}

func (m *SwarmSpec) contextValidateDispatcher(ctx context.Context, formats strfmt.Registry) error {

	if m.Dispatcher != nil {
		if err := m.Dispatcher.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Dispatcher")
			}
			return err
		}
	}

	return nil
}

func (m *SwarmSpec) contextValidateEncryptionConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.EncryptionConfig != nil {
		if err := m.EncryptionConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("EncryptionConfig")
			}
			return err
		}
	}

	return nil
}

func (m *SwarmSpec) contextValidateOrchestration(ctx context.Context, formats strfmt.Registry) error {

	if m.Orchestration != nil {
		if err := m.Orchestration.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Orchestration")
			}
			return err
		}
	}

	return nil
}

func (m *SwarmSpec) contextValidateRaft(ctx context.Context, formats strfmt.Registry) error {

	if m.Raft != nil {
		if err := m.Raft.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Raft")
			}
			return err
		}
	}

	return nil
}

func (m *SwarmSpec) contextValidateTaskDefaults(ctx context.Context, formats strfmt.Registry) error {

	if m.TaskDefaults != nil {
		if err := m.TaskDefaults.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("TaskDefaults")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SwarmSpec) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SwarmSpec) UnmarshalBinary(b []byte) error {
	var res SwarmSpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SwarmSpecCAConfig CA configuration.
//
// swagger:model SwarmSpecCAConfig
type SwarmSpecCAConfig struct {

	// Configuration for forwarding signing requests to an external certificate authority.
	ExternalCAs []*SwarmSpecCAConfigExternalCAsItems0 `json:"ExternalCAs"`

	// An integer whose purpose is to force swarm to generate a new signing CA certificate and key, if none have been specified in `SigningCACert` and `SigningCAKey`
	ForceRotate uint64 `json:"ForceRotate,omitempty"`

	// The duration node certificates are issued for.
	// Example: 7776000000000000
	NodeCertExpiry int64 `json:"NodeCertExpiry,omitempty"`

	// The desired signing CA certificate for all swarm node TLS leaf certificates, in PEM format.
	SigningCACert string `json:"SigningCACert,omitempty"`

	// The desired signing CA key for all swarm node TLS leaf certificates, in PEM format.
	SigningCAKey string `json:"SigningCAKey,omitempty"`
}

// Validate validates this swarm spec c a config
func (m *SwarmSpecCAConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExternalCAs(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SwarmSpecCAConfig) validateExternalCAs(formats strfmt.Registry) error {
	if swag.IsZero(m.ExternalCAs) { // not required
		return nil
	}

	for i := 0; i < len(m.ExternalCAs); i++ {
		if swag.IsZero(m.ExternalCAs[i]) { // not required
			continue
		}

		if m.ExternalCAs[i] != nil {
			if err := m.ExternalCAs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("CAConfig" + "." + "ExternalCAs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this swarm spec c a config based on the context it is used
func (m *SwarmSpecCAConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateExternalCAs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SwarmSpecCAConfig) contextValidateExternalCAs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExternalCAs); i++ {

		if m.ExternalCAs[i] != nil {
			if err := m.ExternalCAs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("CAConfig" + "." + "ExternalCAs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *SwarmSpecCAConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SwarmSpecCAConfig) UnmarshalBinary(b []byte) error {
	var res SwarmSpecCAConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SwarmSpecCAConfigExternalCAsItems0 swarm spec c a config external c as items0
//
// swagger:model SwarmSpecCAConfigExternalCAsItems0
type SwarmSpecCAConfigExternalCAsItems0 struct {

	// The root CA certificate (in PEM format) this external CA uses to issue TLS certificates (assumed to be to the current swarm root CA certificate if not provided).
	CACert string `json:"CACert,omitempty"`

	// An object with key/value pairs that are interpreted as protocol-specific options for the external CA driver.
	Options map[string]string `json:"Options,omitempty"`

	// Protocol for communication with the external CA (currently only `cfssl` is supported).
	// Enum: [cfssl]
	Protocol *string `json:"Protocol,omitempty"`

	// URL where certificate signing requests should be sent.
	URL string `json:"URL,omitempty"`
}

// Validate validates this swarm spec c a config external c as items0
func (m *SwarmSpecCAConfigExternalCAsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var swarmSpecCAConfigExternalCAsItems0TypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["cfssl"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		swarmSpecCAConfigExternalCAsItems0TypeProtocolPropEnum = append(swarmSpecCAConfigExternalCAsItems0TypeProtocolPropEnum, v)
	}
}

const (

	// SwarmSpecCAConfigExternalCAsItems0ProtocolCfssl captures enum value "cfssl"
	SwarmSpecCAConfigExternalCAsItems0ProtocolCfssl string = "cfssl"
)

// prop value enum
func (m *SwarmSpecCAConfigExternalCAsItems0) validateProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, swarmSpecCAConfigExternalCAsItems0TypeProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SwarmSpecCAConfigExternalCAsItems0) validateProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.Protocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtocolEnum("Protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this swarm spec c a config external c as items0 based on context it is used
func (m *SwarmSpecCAConfigExternalCAsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SwarmSpecCAConfigExternalCAsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SwarmSpecCAConfigExternalCAsItems0) UnmarshalBinary(b []byte) error {
	var res SwarmSpecCAConfigExternalCAsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SwarmSpecDispatcher Dispatcher configuration.
//
// swagger:model SwarmSpecDispatcher
type SwarmSpecDispatcher struct {

	// The delay for an agent to send a heartbeat to the dispatcher.
	// Example: 5000000000
	HeartbeatPeriod int64 `json:"HeartbeatPeriod,omitempty"`
}

// Validate validates this swarm spec dispatcher
func (m *SwarmSpecDispatcher) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this swarm spec dispatcher based on context it is used
func (m *SwarmSpecDispatcher) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SwarmSpecDispatcher) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SwarmSpecDispatcher) UnmarshalBinary(b []byte) error {
	var res SwarmSpecDispatcher
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SwarmSpecEncryptionConfig Parameters related to encryption-at-rest.
//
// swagger:model SwarmSpecEncryptionConfig
type SwarmSpecEncryptionConfig struct {

	// If set, generate a key and use it to lock data stored on the managers.
	// Example: false
	AutoLockManagers bool `json:"AutoLockManagers,omitempty"`
}

// Validate validates this swarm spec encryption config
func (m *SwarmSpecEncryptionConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this swarm spec encryption config based on context it is used
func (m *SwarmSpecEncryptionConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SwarmSpecEncryptionConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SwarmSpecEncryptionConfig) UnmarshalBinary(b []byte) error {
	var res SwarmSpecEncryptionConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SwarmSpecOrchestration Orchestration configuration.
//
// swagger:model SwarmSpecOrchestration
type SwarmSpecOrchestration struct {

	// The number of historic tasks to keep per instance or node. If negative, never remove completed or failed tasks.
	// Example: 10
	TaskHistoryRetentionLimit int64 `json:"TaskHistoryRetentionLimit,omitempty"`
}

// Validate validates this swarm spec orchestration
func (m *SwarmSpecOrchestration) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this swarm spec orchestration based on context it is used
func (m *SwarmSpecOrchestration) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SwarmSpecOrchestration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SwarmSpecOrchestration) UnmarshalBinary(b []byte) error {
	var res SwarmSpecOrchestration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SwarmSpecRaft Raft configuration.
//
// swagger:model SwarmSpecRaft
type SwarmSpecRaft struct {

	// The number of ticks that a follower will wait for a message from the leader before becoming a candidate and starting an election. `ElectionTick` must be greater than `HeartbeatTick`.
	//
	// A tick currently defaults to one second, so these translate directly to seconds currently, but this is NOT guaranteed.
	//
	// Example: 3
	ElectionTick int64 `json:"ElectionTick,omitempty"`

	// The number of ticks between heartbeats. Every HeartbeatTick ticks, the leader will send a heartbeat to the followers.
	//
	// A tick currently defaults to one second, so these translate directly to seconds currently, but this is NOT guaranteed.
	//
	// Example: 1
	HeartbeatTick int64 `json:"HeartbeatTick,omitempty"`

	// The number of snapshots to keep beyond the current snapshot.
	KeepOldSnapshots uint64 `json:"KeepOldSnapshots,omitempty"`

	// The number of log entries to keep around to sync up slow followers after a snapshot is created.
	// Example: 500
	LogEntriesForSlowFollowers uint64 `json:"LogEntriesForSlowFollowers,omitempty"`

	// The number of log entries between snapshots.
	// Example: 10000
	SnapshotInterval uint64 `json:"SnapshotInterval,omitempty"`
}

// Validate validates this swarm spec raft
func (m *SwarmSpecRaft) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this swarm spec raft based on context it is used
func (m *SwarmSpecRaft) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SwarmSpecRaft) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SwarmSpecRaft) UnmarshalBinary(b []byte) error {
	var res SwarmSpecRaft
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SwarmSpecTaskDefaults Defaults for creating tasks in this cluster.
//
// swagger:model SwarmSpecTaskDefaults
type SwarmSpecTaskDefaults struct {

	// log driver
	LogDriver *SwarmSpecTaskDefaultsLogDriver `json:"LogDriver,omitempty"`
}

// Validate validates this swarm spec task defaults
func (m *SwarmSpecTaskDefaults) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLogDriver(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SwarmSpecTaskDefaults) validateLogDriver(formats strfmt.Registry) error {
	if swag.IsZero(m.LogDriver) { // not required
		return nil
	}

	if m.LogDriver != nil {
		if err := m.LogDriver.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("TaskDefaults" + "." + "LogDriver")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this swarm spec task defaults based on the context it is used
func (m *SwarmSpecTaskDefaults) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLogDriver(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SwarmSpecTaskDefaults) contextValidateLogDriver(ctx context.Context, formats strfmt.Registry) error {

	if m.LogDriver != nil {
		if err := m.LogDriver.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("TaskDefaults" + "." + "LogDriver")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SwarmSpecTaskDefaults) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SwarmSpecTaskDefaults) UnmarshalBinary(b []byte) error {
	var res SwarmSpecTaskDefaults
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SwarmSpecTaskDefaultsLogDriver The log driver to use for tasks created in the orchestrator if
// unspecified by a service.
//
// Updating this value only affects new tasks. Existing tasks continue
// to use their previously configured log driver until recreated.
//
//
// swagger:model SwarmSpecTaskDefaultsLogDriver
type SwarmSpecTaskDefaultsLogDriver struct {

	// The log driver to use as a default for new tasks.
	//
	// Example: json-file
	Name string `json:"Name,omitempty"`

	// Driver-specific options for the selectd log driver, specified
	// as key/value pairs.
	//
	// Example: {"max-file":"10","max-size":"100m"}
	Options map[string]string `json:"Options,omitempty"`
}

// Validate validates this swarm spec task defaults log driver
func (m *SwarmSpecTaskDefaultsLogDriver) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this swarm spec task defaults log driver based on context it is used
func (m *SwarmSpecTaskDefaultsLogDriver) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SwarmSpecTaskDefaultsLogDriver) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SwarmSpecTaskDefaultsLogDriver) UnmarshalBinary(b []byte) error {
	var res SwarmSpecTaskDefaultsLogDriver
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
